#!/usr/bin/env python

# HiC-Pro
# Copyleft 2015 Institut Curie
# Author(s): Nicolas Servant, Eric Viara
# Contact: nicolas.servant@curie.fr
# This software is distributed without any guarantee under the terms of the
# GNU General
# Public License, either Version 2, June 1991 or Version 3, June 2007.

"""
Script to keep only valid 3C products - DE and SC are removed
"""

import getopt
import sys
import os
import re
from bx.intervals.intersection import Intersecter, Interval


def usage():
    """Usage function"""
    print("Usage : python mapped_2hic_fragments.py")
    print("-i/--validPairs <list of valid Hi-C pairs as generated by HiC-Pro>")
    print("-f/--fragmentFile <Restriction fragment file (BED)>")
    print("-t/--target <Target file for viewpoints (BED)>")
    print("[-c/--cis] <Restrict the analysis to cis contact>")
    print("[-e/--exclusion] <Size of the regions upstream/downstream the capture sites to discard>")
    print("[-o/--oprefix] <Output file prefix>")
    print("[-v/--verbose] <Verbose>")
    print("[-h/--help] <Help>")
    return

def get_args():
    """Get argument"""
    try:
        opts, args = getopt.getopt(
            sys.argv[1:],
            "i:f:t:e:o:cvh",
            ["validPairsFile=",
             "fragmentsFile=",
             "targetFile=",
             "exclusionSize=",
             "oprefix=", 
             "cis", "verbose", "help"])
    except getopt.GetoptError:
        usage()
        sys.exit(-1)
    return opts


def load_BED(in_file, exclusionSize=0, chroms=None, verbose=False):
    """
    Read a BED file and store the intervals in a tree

    Intervals are zero-based objects. The output object is a hash table with
    one search tree per chromosome

    in_file = input file [character]
    verbose = verbose mode [logical]

    """
    x = {}
    x_ex = {}
    skipped_chrom = []
    if verbose:
        print("## Loading BED file {} ...".format(in_file), file=sys.stderr)
    nline = 0
    with open(in_file) as bed_handle:
        for line in bed_handle:
            if len(line.strip()) == 0:
                continue
            if nline % 1000000 == 0 and nline != 0 and verbose:
                sys.stderr.write("{} million lines loaded\n".format(int(nline/1000000)))
            nline += 1
            bedtab = line.split("\t")
            try:
                chromosome, start, end, name = bedtab[:4]
            except ValueError:
                print("Warning : wrong input format in line {}. Not a BED file !?".format(nline), file=sys.stderr)
                sys.exit(1)
                continue
            
            # BED files are zero-based as Intervals objects
            start = int(start)  # + 1
            end = int(end)
            name = name.strip()

            if chroms is not None and chromosome not in chroms:
                if chromosome not in skipped_chrom:
                    print("Warning : Restrict to cis interactions - {} skipped".format(chromosome), file=sys.stderr)
                    skipped_chrom.append(chromosome)
                continue
            
            if chromosome in x:
                tree = x[chromosome]
                tree.add_interval(Interval(start, end, value={'name': name}))
            else:
                tree = Intersecter()
                tree.add_interval(Interval(start, end, value={'name': name}))
                x[chromosome] = tree             
            ## Exclusion regions
            if exclusionSize > 0:
                if chromosome in x_ex:
                    tree_ex = x_ex[chromosome]
                    tree_ex.add_interval(Interval(start - int(exclusionSize), start, value={'name': str(name) + "_up"}))
                    tree_ex.add_interval(Interval(end, end + int(exclusionSize), value={'name': str(name) + "_dwn"}))
                else:
                    tree_ex = Intersecter()
                    tree_ex.add_interval(Interval(start - int(exclusionSize), start, value={'name': str(name) + "_up"}))
                    tree_ex.add_interval(Interval(end, end + int(exclusionSize), value={'name': str(name) + "_dwn"}))
                    x_ex[chromosome] = tree_ex             
    return (x, x_ex)
    
    

def get_overlapping_fragment(frag, chrom, pos, quiet=False, allow_multiple=False):
    """
    Intersect a given read with the set of restriction fragments

    ##
    frag = the fragments [hash]
    chrom = the chromosome to look at [character]
    read = the read to intersect [AlignedRead]

    """
    if chrom in frag:
        # Overlap with the start of the read (zero-based)
        ifrag = frag[chrom].find(int(pos), int(pos+1))
        if len(ifrag) > 1 and allow_multiple==False:
            if not quiet:
                sys.stderr.write("Warning : {} fragments found for read at {}:{} -skipped {}\n".format(len(ifrag), chrom, pos, ifrag))
            return None
        elif len(ifrag) == 0:
            if not quiet:
                sys.stderr.write("Warning - no fragments found for read at {}:{} -skipped\n".format(chrom, pos))
            return None
        else:
            return ifrag
    else:
        if not quiet:
            sys.stderr.write("Warning - no fragments found for read at {}:{} -skipped\n".format(chrom, pos))
        return None

def init_dict():
    repdict = {}                                                                                                                                                                     
    repdict['c_r_counter'] = 0
    repdict['c_c_counter'] = 0
    repdict['exclu_counter'] = 0
    return(repdict)

if __name__ == "__main__":
    # Read command line arguments
    opts = get_args()
    verbose = False
    cisOnly = False
    oprefix = None
    exclusionSize = 0

    if len(opts) == 0:
        usage()
        sys.exit()

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
            sys.exit()
        elif opt in ("-i", "--validPairs"):
            validPairsFile = arg
        elif opt in ("-f", "--fragmentFile"):
            fragmentFile = arg
        elif opt in ("-t", "--targetFile"):
            targetFile = arg
        elif opt in ("-e", "--exclusion"):
            exclusionSize = arg
        elif opt in ("-o", "--oprefix"):
            oprefix = arg
        elif opt in ("-c", "--cis"):
            cisOnly = True
        elif opt in ("-v", "--verbose"):
            verbose = True
        else:
            assert False, "unhandled option"

    # Verbose mode
    if verbose:
        sys.stderr.write("## make_viewpoints.py\n")
        sys.stderr.write("## validPairsFile={}\n".format(validPairsFile))
        sys.stderr.write("## fragmentFile={}\n".format(fragmentFile))
        sys.stderr.write("## targetFile={}\n".format(targetFile))
        sys.stderr.write("## cisOnly={}\n".format(cisOnly))
        sys.stderr.write("## exclusionSize={}\n".format(exclusionSize))
        sys.stderr.write("## verbose={}\n".format(verbose))


    # Read the BED files
    if verbose:
        sys.stderr.write("## Loading data ...\n")

    (target, exclu) =  load_BED(targetFile, exclusionSize=exclusionSize, verbose=verbose)
    if cisOnly:
        resFrag = load_BED(fragmentFile, chroms=target.keys(), verbose=verbose)[0]
    else:
        resFrag = load_BED(fragmentFile, verbose=verbose)[0]
        
    # Read the validPairs file
    if verbose:
        sys.stderr.write("## Opening file {} ...\n".format(validPairsFile))
   
    nline = 0
    repdict = {}

    r_r_counter, ua_counter = 0, 0

    with open(validPairsFile) as in_handle:
        if nline % 1000000 == 0 and nline > 0 and verbose:
            sys.stderr.write("{} lines processed\n".format(nline))
        for line in in_handle:
            nline += 1
            intab = line.split("\t")
            try:
                readname, r1_chr, r1_start, r1_strand, r2_chr, r2_start, r2_strand = intab[:7]
            except ValueError:
                sys.stderr.write("Warning : wrong input format in line {}\
                                  .Not a validPairs file !?\n".format(nline))
                continue

            r1_resfrag = r2_resfrag = reporter = reporter_chrom = captures = None
 
            ## Intersect with target
            if len(exclu) > 0:
                r1_resfrag = get_overlapping_fragment(exclu, r1_chr, int(r1_start), quiet=True, allow_multiple=True)
                r2_resfrag = get_overlapping_fragment(exclu, r2_chr, int(r2_start), quiet=True, allow_multiple=True)
                
            if r1_resfrag is None and r2_resfrag is None:
                r1_resfrag = get_overlapping_fragment(target, r1_chr, int(r1_start), quiet=True, allow_multiple=True)
                r2_resfrag = get_overlapping_fragment(target, r2_chr, int(r2_start), quiet=True, allow_multiple=True)

                if r1_resfrag is not None:
                    captures = r1_resfrag  
                else:
                    r1_resfrag = get_overlapping_fragment(resFrag, r1_chr, int(r1_start), quiet=True, allow_multiple=False)
                    if  r1_resfrag is not None:
                        reporter = r1_resfrag[0]
                        reporter_chrom = r1_chr
                    else:
                        ua_counter += 1
                
                if r2_resfrag is not None:
                    captures = r2_resfrag
                else:
                    r2_resfrag = get_overlapping_fragment(resFrag, r2_chr, int(r2_start), quiet=True, allow_multiple=False)
                    if r2_resfrag is not None:
                        reporter = r2_resfrag[0]
                        reporter_chrom = r2_chr
                    else:
                        ua_counter += 1
            else:
                if r1_resfrag is None:
                    xfrag=r2_resfrag
                else:
                    xfrag=r1_resfrag
                for x in xfrag:
                    vp = x.value['name']
                    if not vp in repdict:
                        repdict[vp]=init_dict()
                    repdict[vp]['exclu_counter'] += 1
                
            ## Counts
            if captures is not None and reporter is not None :
                for capture in captures:
                    vp=capture.value['name']
                    if not vp in repdict:
                        repdict[vp] = init_dict()
                    repdict[vp]['c_r_counter'] += 1

                    if reporter.value['name'] in repdict[vp]:
                        repdict[vp][reporter.value['name']]['count'] += 1                                                                             
                    else:
                        repdict[vp][reporter.value['name']] = {'chr':reporter_chrom, 'start':reporter.start, 'end':reporter.end, 'count':1}

            elif captures is not None and reporter is None:
                for capture in captures:
                    vp=capture.value['name']
                    if not vp in repdict:
                        repdict[vp] = init_dict()
                    repdict[vp]['c_c_counter'] += 1
            elif captures is None and reporter is not None:
                r_r_counter += 1

    in_handle.close()

    ## Write
    for k in repdict:
        if oprefix is None:
            ofile=k + ".bedgraph"
        else:
            ofile=oprefix + "_" + k + ".bedgraph"
        print("Writing in " + k + "_viewpoint.bedgraph")
        f = open(ofile, 'w')
        
        f.write("track type=bedGraph name='hicpro {}' description='hicpro {}' visibility=full color=200,100,0 altColor=0,100,200 priority=20\n".format(k, k))
        for key, value in repdict[k].items():
            if 'chr' in key:
                f.write("{}\t{}\t{}\t{}\n".format(value['chr'], str(value['start']),\
                                                str(value['end']), str(value['count'])))


        ## stats
        sys.stderr.write("## [{}] CAP-REP read pairs = {}\n".format(k, repdict[k]['c_r_counter']))
        sys.stderr.write("## [{}] CAP-CAP read pairs = {}\n".format(k, repdict[k]['c_c_counter']))
        sys.stderr.write("## [{}] Excluded reads = {}\n".format(k, repdict[k]['exclu_counter']))
        f.close()

    sys.stderr.write("## REP-REP read pairs = {}\n".format(r_r_counter))
    sys.stderr.write("## UA reads = {}\n".format(ua_counter))
